Отлично. Ниже — **полное, структурированное ТЗ** на перевод проекта **Jinny Lamp** на **time-based (временной) анимационный движок**, **с учётом всей истории этого чата, уже принятых решений и инвариантов**.
Документ можно класть в `docs/` как референс и использовать как чек-лист при правках.

---

# ТЗ: Переход Jinny Lamp на Time-Based Animation Engine

## 0. Контекст и мотивация

Текущая система анимаций исторически опиралась на:

* frame-based / step-based логику,
* неявную связь “скорость ↔ FPS ↔ phase/step”,
* побочные эффекты при паузе (рестарт, потеря состояния),
* деградацию визуала при изменении FPS (особенно заметно на FIRE).

В ходе рефакторинга power-логики и паузы выявлено:

* FPS стал нестабильным и субъективно «медленным»,
* speed_pct влияет неинтуитивно,
* дальнейшее развитие (сложные FX, DOA, оверлеи) в текущей модели приведёт к наращиванию костылей.

**Решение:** перейти на **чистую time-based модель**, где:

* скорость анимации определяется временем, а не кадрами,
* FPS влияет только на плавность,
* пауза — это freeze времени, а не стоп таска,
* DOA и другие “живые” источники не умирают при паузе,
* старое legacy полностью удаляется.

---

## 1. Цели (Definition of Done)

### Функциональные

1. Анимации выглядят **одинаково по скорости** при 10 / 15 / 20 FPS.
2. `speed_pct` масштабирует **время**, а не шаги.
3. `pause`:

   * замораживает анимационное время,
   * **не останавливает show()**,
   * **не убивает DOA**.
4. DOA-эффекты продолжают обновляться при паузе.
5. Выход из паузы **не перезапускает** анимацию.
6. В коде **не остаётся legacy** (phase, base_step, frame counters).

### Архитектурные

7. FX **не знают про FPS**.
8. FX **не хранят внутренние счётчики кадров**.
9. Вся логика времени централизована в одном месте.
10. API для новых FX простое и документированное.

---

## 2. Ключевые принципы новой модели

### 2.1 Два времени (обязательно)

В системе вводятся **два независимых времени**:

#### 1) Wall-clock (реальное время)

Используется для:

* DOA,
* фильтров (attack/release),
* внешних сенсоров,
* любых “живых” процессов.

Характеристики:

* всегда идёт,
* не зависит от pause,
* измеряется в `ms`.

#### 2) Animation-clock (время анимации)

Используется для:

* всех визуальных FX (fire, simple, particles и т.д.).

Характеристики:

* растёт **только когда не paused**,
* масштабируется `speed_pct`,
* замораживается при pause,
* обнуляется при смене эффекта.

---

## 3. Изменения по модулям (P0)

### 3.1 `matrix_anim` — Master Clock

**Роль:** единственный владелец времени анимации и FPS.

#### Добавить состояние:

```c
uint32_t wall_ms;
uint32_t wall_dt_ms;

uint32_t anim_ms;
uint32_t anim_dt_ms;
```

#### Логика task:

1. Каждый тик:

   * считать `wall_ms`, `wall_dt_ms` (через esp_timer).
2. Если `paused == false`:

   * `anim_dt_ms = wall_dt_ms * speed_scale`
   * `anim_ms += anim_dt_ms`
3. Если `paused == true`:

   * `anim_dt_ms = 0`
   * `anim_ms` не меняется
4. Вызвать `fx_engine_render(...)`
5. Вызвать `matrix_ws2812_show()` **всегда**

#### FPS:

* задаётся константой (дефолт **15 FPS**),
* можно менять compile-time.

---

### 3.2 `fx_engine` — чистый time-consumer

#### Удалить полностью:

* `phase`
* `frame`
* `base_step`
* `step_from_pct`
* любые phase-advance функции

#### Новый контракт:

```c
void fx_engine_render(
    uint32_t wall_ms,
    uint32_t wall_dt_ms,
    uint32_t anim_ms,
    uint32_t anim_dt_ms
);
```

`fx_engine`:

* **не считает время**,
* **не масштабирует скорость**,
* просто прокидывает значения в текущий FX.

---

### 3.3 `fx_ctx_t` (контекст эффекта)

Обязательные поля:

```c
struct fx_ctx_t {
    // canvas, размеры, буферы
    // параметры (brightness, etc.)

    uint32_t wall_ms;
    uint32_t wall_dt_ms;

    uint32_t anim_ms;
    uint32_t anim_dt_ms;
};
```

Запрещено:

* хранить счётчики кадров,
* хранить phase,
* хранить “накопленный step”.

---

### 3.4 `fx_registry`

#### Удалить:

* `base_step` из `fx_desc_t`.

#### Новый формат:

```c
typedef struct {
    uint16_t id;
    const char *name;
    void (*render)(fx_ctx_t *ctx);
} fx_desc_t;
```

---

### 3.5 Эффекты (`fx_effects_*`)

#### Общие правила (обязательно):

1. FX **использует только**:

   * `ctx->anim_ms` / `ctx->anim_dt_ms` для анимации,
   * `ctx->wall_ms` / `ctx->wall_dt_ms` для DOA/сенсоров.
2. FX **не знает**:

   * FPS,
   * speed_pct,
   * paused.
3. Любая периодика — через время:

   ```c
   float t = ctx->anim_ms * 0.001f;
   ```

#### DOA-эффекты:

* используют `wall_*`,
* продолжают обновляться при pause,
* допускается комбинирование:

  * геометрия по anim,
  * угол/энергия по wall.

---

## 4. Pause — строгая семантика

### Что pause делает:

* замораживает `anim_ms`,
* оставляет `wall_ms` активным,
* **не останавливает task**,
* **не останавливает show()**.

### Что pause НЕ делает:

* не стопает matrix_anim,
* не вызывает stop/start,
* не сбрасывает состояние FX.

---

## 5. Power / SOFT OFF / DEEP SLEEP (инварианты)

Переход на time-based **не меняет** принятую power-архитектуру:

* `power_management` остаётся отдельным state machine.
* SOFT OFF:

  * stop(join),
  * DATA LOW,
  * MOSFET OFF,
  * игнор всех команд кроме POWER ON.
* DEEP SLEEP — только через кнопку.
* Time-engine не активен в SOFT OFF.

---

## 6. Legacy — политика нулевая

Принято решение:

> **Если элемент не нужен в новой модели — он удаляется.**

Обязательному удалению подлежит:

* phase,
* base_step,
* frame counters,
* step_from_pct,
* любые комментарии/ветки “на будущее”.

Проект после миграции **не должен компилироваться**, если кто-то попытается написать FX по старой модели.

---

## 7. План миграции (по шагам)

### Шаг 0 — Git checkpoint

* commit + tag перед началом.

### Шаг 1 — Core

* переписать `matrix_anim`,
* переписать `fx_engine`,
* переписать `fx_registry`.

### Шаг 2 — FX

* переписать `fx_effects_simple`,
* переписать `fx_effects_fire`,
* переписать `fx_effects_doa_debug`.

### Шаг 3 — Cleanup

* удалить legacy код,
* удалить неиспользуемые поля/функции,
* убедиться, что build чистый.

### Шаг 4 — Verification

* визуально проверить:

  * скорость,
  * pause/resume,
  * DOA при pause,
* проверить при 10 / 15 / 20 FPS.

---

## 8. Ограничения и ожидания

* Целевой FPS по умолчанию: **15 FPS**.
* Допустимо: 20 FPS.
* FX должны выглядеть корректно даже при 10 FPS.
* Производительность важнее “максимального FPS”.

---

## 9. Итог

После выполнения ТЗ проект получает:

* прозрачную временную модель,
* предсказуемые анимации,
* корректную паузу,
* живой DOA,
* чистую архитектуру без legacy,
* удобную базу для новых FX.

---

Если хочешь, следующим шагом я могу:

* превратить это ТЗ в **ADR (Architectural Decision Record)**,
* или сразу начать **Шаг 1** и дать точные копипасты по файлам.
