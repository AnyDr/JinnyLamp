# HANDOFF — Jinny Lamp (ESP32-S3 + XVF3800 + WS2812)

Этот документ фиксирует текущее состояние проекта и то, как быстро продолжить работу без “разгона по чату”.

Связанные документы:
- docs/README.md — входная дверь в проект
- docs/architecture.md — модули, потоки, задачи, инварианты
- docs/commands.md — команды разработчика и семантика управления
- docs/espnow.md — ESP-NOW: pairing, канал, протокол CTRL/ACK
- docs/analysis/tech_debt.md — риски и задачи (P0–P2)
- docs/fx_fire.md — документация эффекта FIRE (если актуально)

---

## 1) Аппаратная архитектура (факт)
### 1.1 Плата/MCU
- Базовая плата: ReSpeaker XVF3800 с интегрированным XIAO ESP32-S3.
- Архитектура: host (ESP32-S3) + voice DSP (XVF3800).

### 1.2 Связь ESP32-S3 ↔ XVF3800
- I2C: управление XVF и его GPIO/GPO.
- I2S: аудио RX/TX (тракты и пины см. audio_i2s.*).

### 1.3 Световая часть
- WS2812B: 3 матрицы 16×16, daisy-chain → 48×16 = 768 LED.
- DATA: GPIO3 ESP32-S3 → 74AHCT125 (5V) → 330–470Ω → матрицы.
- Питание матриц: +5V напрямую, GND через low-side N-MOSFET.
- Gate MOSFET: XVF3800 GPO X0D11 (Rgate ~100Ω + pulldown ~100k, опц. Cgs 10–47nF).

Критические инварианты:
- Включение: DATA=LOW → MOSFET ON → задержка → передача.
- Выключение: stop anim → DATA=LOW → MOSFET OFF.

---

## 2) База софта (факт)
- ESP-IDF: v5.5.1
- WS2812: led_strip (RMT + DMA на ESP32-S3)
- Главные модули:
  - main.c — app_main(), порядок инициализации
  - matrix_ws2812.* — framebuffer + show
  - matrix_anim.* — единственный владелец show, кадры ~10 FPS
  - fx_engine.* / fx_canvas.* / fx_registry.* — движок эффектов
  - ctrl_bus.* — источник истины состояния (effect/brightness/speed/paused/power/state_seq)
  - j_wifi.* — Wi-Fi канал и стратегия fallback
  - j_espnow_link.* + j_espnow_proto.h — ESPNOW протокол и обработка команд
  - audio_i2s.* / asr_debug.* — аудио тракт и диагностика (опционально)

---

## 3) Текущее состояние по памяти/flash/PSRAM (обновлено в OTA-сессии)
- Flash: выставлено 8MB (boot лог показывает SPI Flash Size = 8MB).
- PSRAM: обнаружено 8MB PSRAM (octal PSRAM, memory test OK).
- Partition table: включён OTA-режим + FS (LittleFS):
  - `ota_0` ≈ 2.5MB
  - `ota_1` ≈ 2.5MB
  - `fs` (LittleFS) ≈ 2.8–3.2MB
- Цель FS: хранить ассеты (аудио ADPCM/модели/статические файлы OTA-портала).

Примечание: ранее была конфигурация `factory=1MB`; теперь вектор принят на OTA-схему, чтобы проект не “упёрся” в размер приложения.

---

## 4) OTA: текущий прогресс (что уже сделано)
Сделано:
1) Переведён flash на 8MB и подтверждено на железе.
2) Включена PSRAM и подтверждено на железе.
3) Подготовлен путь к кастомной таблице разделов (CSV в репо).
4) В протокол ESPNOW добавлена команда `J_ESN_CMD_OTA_START` (без UI на пульте пока).
5) Проект собирается и прошивается после внедрения OTA-partition.

Важно (ограничение):
- Интерактивный ввод через `idf.py monitor` может быть недоступен (serial write timeout), поэтому OTA-триггер через “ввести команду в monitor” НЕ считается базовым решением.

---

## 5) OTA: целевое решение (push-OTA web portal через SoftAP)
Цель: обновление “с ноутбука” без проводов, без сложных тулов, с минимальной вероятностью кирпича.

План целевого UX:
1) Пользователь инициирует OTA со стороны пульта (кнопка “Start OTA” на скрытом экране) или позже резервно через кнопку.
2) Лампа:
   - мгновенно останавливает анимацию
   - трижды мигает красным (служебная анимация)
   - выключает питание матриц по инварианту (DATA=LOW → MOSFET OFF)
   - поднимает SoftAP “JINNY-OTA”
   - поднимает HTTP-страницу “Firmware Update” (upload .bin)
3) После успешной записи:
   - валидация
   - переключение boot на новый OTA-слот
   - reboot
4) Rollback: если новый слот не стартовал корректно — откатиться на прошлый.

---

## 6) Голосовой сценарий “Джин”: целевое поведение (первоначальный план)
Цель: поверх любой текущей анимации показывать “джина”, который:
- появляется только после wake word,
- смотрит на говорящего (по DOA), с deadband ±5°,
- в режиме LISTEN лицо статично,
- в режиме SPEAK рот двигается синхронно с воспроизведением аудио-ответа,
- базовая анимация при этом не останавливается (кроме случая power off/OTA режима).

Факты/предпосылки:
- XVF3800 умеет выдавать DOA/azimuth (есть подтверждение чтения azimuth параметра как XVF feature).
- Аудио RX (XVF → ESP по I2S) уже поднято; обратный тракт (ESP → XVF → speaker) требуется реализовать.

---

## 7) “Пересечение” OTA и голосовой части (главная идея)
OTA и голосовая подсистема пересекаются в двух местах:

1) Доставка ассетов без перекомпиляции:
   - аудио-файлы ответов (ADPCM)
   - модели/параметры маленькой нейросети (WakeNet/VAD/команды)
   - конфиги (пороги, deadband, режимы)
   Всё это хранится в LittleFS и может обновляться отдельной процедурой (позже).

2) Безопасное поле экспериментов:
   - голосовой стек будет меняться часто,
   - OTA позволяет не бояться “больших изменений” и быстро откатываться при регрессиях.

---

## 8) TODO (следующие шаги, по порядку)

### A) OTA (P0)
1) Добавить модуль `ota_portal.*` (SoftAP + http upload).
2) Сделать служебную “красную тройную вспышку” и корректный power-off матриц при входе в OTA.
3) Реализовать ESPNOW-триггер OTA:
   - принять `J_ESN_CMD_OTA_START` в лампе
   - вызвать `ota_portal_start()`
4) На пульте: добавить скрытый экран “Lamp Tools” с одной кнопкой “Start OTA”
   - доступ: только когда выбран Lamp, вход по “безопасной” комбинации (без случайных нажатий)

### B) Аудио TX (P0–P1)
1) Реализовать тракт ESP → XVF по I2S (проверить формат/частоту).
2) Добавить простой плеер аудио из LittleFS (ADPCM декод → PCM → I2S write).
3) Убедиться, что воспроизведение не ломает LED-тайминги (приоритеты задач).

### C) DOA (P1)
1) Добавить чтение DOA/azimuth из XVF по I2C, вынести в отключаемый debug-режим.
2) Сглаживание/порог ±5° и параметры follow вынести в define/конфиг.

### D) Voice pipeline / маленькая модель (P1)
1) Wake word (WakeNet) + VAD (или сигнал “speech present” от XVF после wake).
2) Локальные команды (малый набор) + таймер “макс. время слушания”.
3) Фоллбек на сервер (позже): если локальная модель не уверена — отправить на “домашний мозг” (Wi-Fi/MQTT).

### E) Overlay “Джин” (P1–P2)
1) Ввести `fx_overlay` слой, композиция поверх любого эффекта.
2) Режимы: IDLE / LISTEN / SPEAK.
3) Привязка угла DOA к X-смещению лица, плавное следование.

---

## 9) Как быстро продолжить работу (что прислать в следующий раз)
1) `git describe --tags --always --dirty`
2) `git log -15 --oneline`
3) файлы, если менялись:
   - partitions/*.csv
   - main/j_espnow_proto.h
   - main/j_espnow_link.c
   - main/j_wifi.c
   - main/audio_i2s.*
   - main/xvf_i2c.*
   - main/matrix_ws2812.*
   - (новое) main/ota_portal.*
   - (новое) main/fx_overlay.*

