Карта модулей и потоков данных: кто кого вызывает, какие таски, какие очереди/события, где границы ответственности.

# Архитектура Jinny Lamp

## 1) High level
Проект строится вокруг “исполнителя” (лампы) как источника истины состояния эффектов.

Команды приходят:
- локально от TTP223 (short/double/triple/long),
- удаленно по ESP-NOW от пульта,
- планируется: от сервера (Wi-Fi/MQTT, Home Assistant).

Состояние хранится и применяется в лампе через ctrl_bus. Пульт является клиентом, отправляющим команды и обновляющим UI по ACK snapshot.

## 2) Основные подсистемы
### 2.1 Rendering pipeline (LED)
- matrix_anim task (периодический кадр, примерно 10 FPS)
- fx_engine_render(t_ms) -> рисует в fx_canvas
- fx_canvas -> копирование/маппинг в framebuffer matrix_ws2812 (если так устроено в текущей реализации)
- matrix_ws2812_show() -> единственный push на WS2812

Инвариант: “show” должен быть в одном месте (владение одним task), чтобы не получить гонки и артефакты.

### 2.2 FX engine и registry
- fx_registry хранит список эффектов: (id / name / base_step / render callback)
- fx_engine управляет текущим эффектом и параметрами, вызывает render с учетом времени и speed_pct

Главная проблема для ESPNOW SET_ANIM: effect_id должен совпадать у пульта и fx_registry лампы.

### 2.3 Управление состоянием (ctrl_bus)
ctrl_bus - “single source of truth”:
- effect_id (uint16)
- brightness (uint8) - 0..255 (семантика 0 оговаривать отдельно)
- speed_pct (uint16) - 10..300 (%)
- paused (bool)
- power (bool, если выделено в протоколе/логике)
- seq/state_seq (монотонный счетчик примененных изменений)

ctrl_bus принимает команды (локальные или ESPNOW), нормализует/клампит диапазоны, применяет к подсистемам и возвращает snapshot для ACK.

### 2.4 Wireless (Wi-Fi + ESPNOW)
Wi-Fi STA поднимается как радио-стек.
ESPNOW работает на текущем канале Wi-Fi, поэтому каналом надо управлять централизованно (j_wifi):
- если SSID задан и STA подключен: канал диктует AP
- если SSID пустой или STA не подключен: fallback channel CONFIG_J_WIFI_FALLBACK_CH

См. docs/espnow.md (детали протокола, pairing, команда/ACK).

### 2.5 Audio (XVF3800)
- I2C: управление XVF и его GPIO
- I2S: аудио RX/TX (см. audio_i2s.*)
- asr_debug: диагностическая задача (калибровка noise_floor, расчет уровня, логи, управление статусным LED)
ВНИМАНИЕ: asr_debug может генерировать много логов, что мешает читать логи ESPNOW. См. docs/commands.md как приглушить.

### 2.6 Power sequencing матриц
Аппаратно: матрицы питаются через low-side MOSFET на земле.
Инвариант:
- Включение: DATA=LOW -> MOSFET ON -> задержка -> передача кадра
- Выключение: stop anim -> DATA=LOW -> MOSFET OFF

Этот порядок обязателен, иначе возможны “случайные вспышки”, неверная инициализация WS2812 и паразитное питание через DATA.

## 3) Потоки данных (упрощенная схема)
1) UI/Remote -> ESPNOW CTRL -> Lamp
2) Lamp: j_espnow_link RX -> ctrl_bus_submit()
3) ctrl_bus применяет и обновляет state_seq
4) Lamp -> ESPNOW ACK (snapshot state) -> Remote UI
5) matrix_anim task периодически вызывает fx_engine и показывает кадр

## 4) Точки входа и задачи
- app_main (main.c): создает и инициализирует подсистемы
- matrix_anim task: рендер кадров
- (опционально) asr_debug task: аудио диагностика
- (опционально) input_ttp223 task: polling кнопки и генерация команд

Факт из логов: Wi-Fi/ESPNOW поднимаются очень рано (до эффекторной части), затем XVF/I2C и остальные подсистемы.

## 5) Диагностика и наблюдаемость
Смотри теги логов:
- J_WIFI: режим STA, MAC, канал, fallback логика
- J_ESPNOW / ESPNOW: init, peer, RX/TX, ACK
- CTRL_BUS: применение состояния (если включены логи)
- MATRIX_WS2812 / MATRIX_ANIM: init и показ
- ASR_DEBUG: калибровка и уровень (можно временно приглушать)

## 6) Известные проблемы / TODO (зафиксировать)
- SET_ANIM не будет работать корректно, пока таблица effect_id на пульте не синхронизирована с fx_registry лампы
- Команды с пульта могут уходить в лампу даже при переключении экрана/устройства на пульте (логика пульта)
- Риск по каналу Wi-Fi при будущем MQTT: ESPNOW обязан следовать каналу STA, иначе связь “пропадает”
- Если появляются предупреждения про flash size, надо проверить настройки flash/partition (sdkconfig и таблицу разделов)
