Что именно “дергает” FIRE на новой схеме времени

В fx_fire_render() ты делаешь дискретную симуляцию с фиксированным step_ms = FIRE_BASE_STEP_MS и накопителем s_accum_ms:

каждый кадр добавляешь dt_ms = ctx->anim_dt_ms в s_accum_ms

пока s_accum_ms >= step_ms выполняешь целый сим-шаг, вычитая step_ms

Это классическая схема, но у неё есть жёсткий порог.

Если dt_ms гуляет вокруг step_ms (или кратности), получается паттерн:

кадр A: dt=38 → шагов 0

кадр B: dt=42 → накопилось 80 → шагов 2

визуально это выглядит как “тишина → рывок → тишина → рывок”

И это как раз совпадает с твоими наблюдениями типа “несколько раз через 250мс, потом через 150мс”, только на огне оно проявляется как микродёрг.

Почему на легasy могло “казаться” лучше:

там либо был более стабильный dt (другая схема сна/тики), либо step_ms был существенно меньше среднего dt (например, 20ms при 10–12 FPS), и пороговый эффект меньше ловился глазом.

Ссылки на место проблемы прямо в твоём коде: step_ms = FIRE_BASE_STEP_MS; ... while (s_accum_ms >= step_ms) { ... } 

fx_effects_fire.c


И по контракту времени: ctx->anim_dt_ms уже “правильный” анимационный dt (скорость/пауза применены в master clock). 

fx_engine.h

Что мы делаем (план), без ухудшения визуала огня

Твоя цель “+50% плавности” достигается не “сделать огонь проще”, а убрать пороговую дерготню симуляции.

Есть 3 варианта, от самого дешёвого к самому правильному:

Вариант A (самый быстрый, почти без кода): уменьшить FIRE_BASE_STEP_MS

Суть: сделать step_ms заметно меньше среднего dt кадра, чтобы почти всегда выполнялось одинаковое число шагов.

Если сейчас у тебя FPS=25 (период ~40ms), то:

FIRE_BASE_STEP_MS = 20ms → почти всегда 2 шага на кадр

FIRE_BASE_STEP_MS = 16ms → почти всегда 2–3 шага на кадр

Это реально даёт визуальную плавность, потому что исчезает паттерн “0 шагов / 2 шага”.

⚠️ Риск: CPU вырастет примерно пропорционально числу сим-шагов (в FIRE симуляция ощутимая). Но это не “ухудшение картинки”, это “больше физики на секунду” (скорее даже улучшение).

Что важно: при уменьшении FIRE_BASE_STEP_MS общая скорость огня изменится (он станет быстрее). Это корректируется НЕ упрощением, а компенсацией “скоростей” (ниже).

Вариант B (правильнее, но чуть кодинга): интерполяция рендера между шагами (subframe)

Суть: симуляция идёт дискретно, но картинку рисуем как смесь “предыдущего” и “текущего” состояния по доле alpha = s_accum_ms / step_ms.

То есть:

делаем шаги только когда нужно

но между шагами картинка плавно “едет” (без порогового строба)

Это убирает дерготню даже при редких шагах (можно держать FIRE_BASE_STEP_MS=40 и всё равно будет мягче).

⚠️ Риск: нужно хранить “предыдущее” поле (ещё 16×48 байт, копейки) и аккуратно смешивать при рендере.

Вариант C (движковый, максимально системный): фиксированный dt кадра в matrix_anim + phase-lock

Суть: сделать так, чтобы ctx->anim_dt_ms был максимально стабильным (например ровно 40ms при 25 FPS), тогда даже Вариант A может стать почти идеальным.

⚠️ Риск: это уже правка matrix_anim.c (движок), а ты сейчас просишь “не ломать, улучшить параметрами”. Поэтому я бы это держал как второй этап.

Какие параметры трогаем прямо сейчас (минимально-инвазивно)
1) Симуляционный шаг

поставить FIRE_BASE_STEP_MS = 20u (вместо 40u) 

fx_effects_fire.c


Это главный “анти-дерг” переключатель.

2) Компенсация скорости огня (чтобы он не стал “в 2 раза быстрее”)

У тебя скорость визуально задают в основном:

FIRE_UPFLOW

FIRE_COOL_BASE и FIRE_COOL_Y_SLOPE

частоты событий, завязанные на “шаги” (life_steps и rate-штуки)

Если шаг стал в 2 раза чаще, а ты хочешь примерно тот же темп, делаем так:

уменьшить “на шаг” действия примерно в 2 раза, но это не всегда линейно.
Практическая стартовая пара (почти всегда заходит без потери красоты):

FIRE_UPFLOW: было 205 → сделать ~180..190 (чуть “тяжелее” вверх)

FIRE_COOL_BASE: было 6 → сделать 5 (чтобы не пересушить)

FIRE_COOL_Y_SLOPE: было 3 → оставить 3 (верх всё равно должен тухнуть)

Я бы начал с только FIRE_BASE_STEP_MS=20, посмотреть 30 секунд, и потом уже слегка поджать FIRE_UPFLOW, если огонь стал слишком “нервный”.

3) Кап dt

FIRE_DT_CAP_MS=120 сейчас норм как защита от лагов. Но если ты держишь FPS 25 и хочешь ровность, можно сделать 80..100, чтобы провалы dt не портили симуляцию “двойными прыжками”. Это НЕ ухудшит огонь, это защитит от редких скачков.

Что я предлагаю делать по шагам (с проверками)

Не трогаем никакие “визуальные” параметры палитры/лепестков/искорок вообще.

Меняем только:

FIRE_BASE_STEP_MS: 40 → 20

(опционально) FIRE_DT_CAP_MS: 120 → 90

Гоним 2–3 минуты, переключая эффекты, возвращаясь в FIRE, включая паузу.

Если FIRE стал слишком “быстрый/нервный”:

чуть опускаем FIRE_UPFLOW (на 10–20 пунктов) и всё.

Вердикт по твоему требованию “без снижения качества огня”

Вариант A (step 20ms) качество не снижает, он делает физику более частой.

Вариант B (интерполяция) вообще “бесплатная плавность” без упрощения.

3 исхода (реалистично)

Позитивный: FIRE_BASE_STEP_MS=20 почти убирает дерготню, огонь выглядит даже лучше, CPU остаётся в норме.

Нейтральный: плавнее стало, но огонь ускорился; лёгкой правкой FIRE_UPFLOW возвращаем темп.

Негативный: CPU упёрся, и начинаются просадки кадра; тогда либо возвращаем step_ms на 25–30, либо делаем Вариант B (интерполяцию), чтобы получить плавность без роста сим-шагов.

Если ок, я дальше сделаю точное предложение изменений (конкретные строки в fx_effects_fire.c), но сначала скажи: ты хочешь сохранить темп огня как был, или тебя устраивает, что он станет чуть “живее/быстрее”, раз ты сам сказал, что при 25 FPS стало лучше?