Ок, продолжаем с **последнего зафиксированного состояния**: DOA DONE, storage+TX smoke test DONE, но **P0-блокер сейчас один**: **I2S арбитраж RX/TX (duplex-safe)**, чтобы исчезли:

* `i2s_channel_enable(): already enabled`
* лавина `audio_i2s_read err=ESP_ERR_TIMEOUT` после playback

Это прямо следует из текущих доков (инварианты + M3/P0).  

Ниже план на **сегодня**, пошагово, без правок “на удачу”.

---

## План на сегодня (P0: I2S арбитраж, без расширений функционала)

### Шаг 0. Git checkpoint перед работой

**Цель:** безопасный откат без “а где было рабочее”.

* `git status`
* `git commit -am "checkpoint: pre_M3_i2s_arbiter"`
* `git tag -a checkpoint/M3_pre_i2s_arbiter -m "pre M3 i2s arbiter work"`
* `git push && git push origin checkpoint/M3_pre_i2s_arbiter`

---

### Шаг 1. Инвентаризация владения I2S (только чтение кода + список точек)

**Цель:** найти все места, где кто-то дёргает enable/disable/init I2S RX/TX.

Составляем список (файл/функция/что делает):

* где создаются каналы I2S (init)
* где вызывается `i2s_channel_enable/disable` или твои `tx_set_enabled()/rx_set_enabled()`
* кто и когда вызывает `audio_i2s_read()` (должен быть только `audio_stream.c`)
* кто пишет TX (должен быть только `audio_player`)

**Результат шага:** короткая таблица “вот эти 6 мест трогают I2S”.

---

### Шаг 2. Фиксация политики M3 в коде (не код, а правило на бумаге)

**Цель:** чтобы мы не “лечили симптом”, а реализовали зафиксированную архитектуру.

Политика (как в документах):

1. I2S поднимается **один раз** (желательно duplex) и дальше **не дёргается на каждый playback**. 
2. На время SPEAK:

   * `audio_stream` → `PAUSED` или `DROP` + `flush`
   * wake/multinet OFF
   * `audio_player` играет (TX write)
   * post-guard + `flush`
   * `audio_stream` NORMAL + wake ON 
3. Повторный enable на уже enabled канал запрещён (идемпотентность). 

**Результат шага:** 10 строк “state machine I2S ownership” (в коммент/доке рядом с `audio_i2s.c`).

---

### Шаг 3. Минимальная реализация “арбитра” без рефакторинга

**Цель:** убрать `already enabled` и предотвратить гонки.

Минимально-инвазивно:

* в `audio_i2s.c` (или модуле рядом) вводим **единственный источник истины**:

  * `static bool rx_enabled; static bool tx_enabled; static bool i2s_inited;`
* делаем функции **идемпотентными**:

  * `audio_i2s_rx_set_enabled(bool on)`:

    * если `on == rx_enabled` → return OK (и лог “already in that state” без ERROR)
    * иначе enable/disable и обновить флаг
  * то же для `audio_i2s_tx_set_enabled(bool on)`
* запрещаем прямые вызовы `i2s_channel_enable()` вне `audio_i2s.c`
* `audio_player` больше **не делает enable**, если он уже сделан на старте (или делает через `audio_i2s_tx_set_enabled()`)

**Результат шага:** исчезает лог `i2s_channel_enable(): already enabled` при обычном playback.

---

### Шаг 4. Разруливание RX timeout после TX (самая важная часть)

**Цель:** после playback RX не должен “умирать”.

Два сценария, выбираем более минимальный по коду (почти наверняка A):

**A) Duplex всегда включён, RX не выключаем никогда**

* I2S init: RX+TX каналы готовы, enable делается один раз при старте.
* На время playback мы не трогаем RX канал, мы лишь:

  * `audio_stream` PAUSED/DROP (чтобы не грузить CPU и не ловить self-feedback)
  * затем возвращаем NORMAL

**B) Если железо/драйвер не тянет реальный duplex**

* тогда на время playback арбитр делает:

  * `audio_stream_pause()` (останавливаем чтение)
  * `rx_set_enabled(false)` (один раз, строго)
  * play TX
  * `tx_set_enabled(false)` (опционально)
  * `rx_set_enabled(true)`
  * `audio_stream_resume()`

Но B хуже тем, что больше “дёргаем железо” и повышаем шанс новых глюков.

**Результат шага:** после окончания playback `audio_stream` снова читает валидные данные (нет лавины timeout).

---

### Шаг 5. Убрать авто-play из main (чтобы тесты не мешали нормальному циклу)

**Цель:** исключить “само играет при загрузке” и побочные эффекты на запуске задач.

* Автозапуск теста оставляем только под `#define AUDIO_PLAYER_AUTOTEST` или под кнопкой/консольной командой.

**Результат шага:** чистый boot без TX активности.

---

### Шаг 6. Тест-план “приёмка M3” (строго по DoD)

**Цель:** доказать, что P0 закрыт. 

1. Boot, 30 секунд idle: DOA probe жив, `audio_stream` стабилен.
2. 50 запусков playback подряд (скриптом/кнопкой):

   * нет `already enabled`
   * нет ребутов
3. Сразу после 50 playback:

   * `audio_stream` снова выдаёт данные без `ESP_ERR_TIMEOUT` лавины
4. (Опционально) включить `asr_debug` и убедиться, что уровень/шум продолжает обновляться.

---

### Шаг 7. Git фиксация результата

* `git commit -am "audio: M3 i2s arbiter idempotent enable; rx/txt coexist; no rx timeouts after tx"`
* `git tag -a checkpoint/M3_i2s_arbiter_ok -m "M3: i2s arbitration stable"`
* `git push && git push origin checkpoint/M3_i2s_arbiter_ok`

---

## Что сегодня сознательно НЕ делаем

* ADPCM decode и voice-pack manifest (это M6, после стабилизации арбитража). 
* WakeNet/MultiNet интеграцию (M4) до закрытия M3. 

---

Если ок, следующий твой шаг: **скинь актуальные файлы**, которые точно участвуют в I2S/TX/RX (минимум: `audio_i2s.c`, `audio_player.c/.h`, `audio_stream.c`, `main.c`), и я по этому плану сделаю “Шаг 1: таблицу точек владения” и выявлю, где именно сейчас происходит двойной enable и почему RX начинает тайм-аутиться.
