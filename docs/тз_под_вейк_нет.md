Что дальше по плану лучше начать
Следующий шаг: закрыть M2 минимально

Сделать Audio Capture слой: одна задача читает I2S RX и складывает в ringbuffer.

Сделать API “дай N сэмплов mono s16” для потребителей (WakeNet, VAD, debug).

asr_debug перевести с прямого audio_i2s_read() на этот API (и loopback сделать опциональным).

Почему так: WakeNet ожидает 16 kHz, mono, signed 16-bit на входе.
А у тебя сейчас формат “int32 слова, 2ch, 24-бит полезные” и нет нормального “audio service” API.

Когда ставить Espressif WakeNet

Сразу после того, как ты выдаёшь стабильный mono s16 поток (M2) и он живёт 10–15 минут без underrun/overrun.
После этого WakeNet интегрируется почти “втыканием вилки”.

Что в текущем коде хорошо и что мешает WakeNet прямо сейчас
Ок

I2S уже 16 kHz, стерео, 32-bit слоты (как транспорт) 

audio_i2s.c

asr_debug уже делает полезную первичную метрику уровня и noise_floor 

asr_debug.c

Мешает

Нет mono s16 выдачи.
Сейчас ты делаешь s24 = raw >> 8 (то есть 24-бит из 32-бит слова). Для s16 тебе нужно ещё >> 8, то есть по сути raw >> 16, но лучше оформить как явную функцию и один раз проверить на осциллограмме/логах, чтобы не словить неверное выравнивание. 

asr_debug.c

asr_debug перезапускает устройство при сериях ошибок I2S (esp_restart()), это плохо для будущего voice FSM. Debug должен деградировать мягко, не валить систему. 

asr_debug.c

Loopback TX в debug сейчас включён всегда. Для WakeNet он не нужен и может мешать (эхо/самовозбуждение), так что нужен флаг “debug loopback enable”. 

asr_debug.c

Минимальный план на следующую сессию (без лишнего)

Новый модуль audio_stream.{h,c}:

task audio_stream_task: читает audio_i2s_read() и пушит в ringbuffer

API: audio_stream_read_mono_s16(int16_t* dst, size_t samples, TickType_t to)

счётчики: overrun/underrun/dropped

В asr_debug:

заменить прямой audio_i2s_read() на audio_stream_read_mono_s16()

сделать loopback опциональным (compile-time define)

убрать esp_restart() из debug-задачи (только лог + backoff)

Дальше сразу WakeNet (M3.1):

подключаем ESP-SR компонент

отдаём ему буфер mono s16 16 kHz