Что дальше по плану лучше начать
Следующий шаг: закрыть M2 минимально

Сделать Audio Capture слой: одна задача читает I2S RX и складывает в ringbuffer.

Сделать API “дай N сэмплов mono s16” для потребителей (WakeNet, VAD, debug).

asr_debug перевести с прямого audio_i2s_read() на этот API (и loopback сделать опциональным).

Почему так: WakeNet ожидает 16 kHz, mono, signed 16-bit на входе.
А у тебя сейчас формат “int32 слова, 2ch, 24-бит полезные” и нет нормального “audio service” API.

Когда ставить Espressif WakeNet

Сразу после того, как ты выдаёшь стабильный mono s16 поток (M2) и он живёт 10–15 минут без underrun/overrun.
После этого WakeNet интегрируется почти “втыканием вилки”.

Что в текущем коде хорошо и что мешает WakeNet прямо сейчас
Ок

I2S уже 16 kHz, стерео, 32-bit слоты (как транспорт) 

audio_i2s.c

asr_debug уже делает полезную первичную метрику уровня и noise_floor 

asr_debug.c

Мешает

Нет mono s16 выдачи.
Сейчас ты делаешь s24 = raw >> 8 (то есть 24-бит из 32-бит слова). Для s16 тебе нужно ещё >> 8, то есть по сути raw >> 16, но лучше оформить как явную функцию и один раз проверить на осциллограмме/логах, чтобы не словить неверное выравнивание. 

asr_debug.c

asr_debug перезапускает устройство при сериях ошибок I2S (esp_restart()), это плохо для будущего voice FSM. Debug должен деградировать мягко, не валить систему. 

asr_debug.c

Loopback TX в debug сейчас включён всегда. Для WakeNet он не нужен и может мешать (эхо/самовозбуждение), так что нужен флаг “debug loopback enable”. 

asr_debug.c

Минимальный план на следующую сессию (без лишнего)

Новый модуль audio_stream.{h,c}:

task audio_stream_task: читает audio_i2s_read() и пушит в ringbuffer

API: audio_stream_read_mono_s16(int16_t* dst, size_t samples, TickType_t to)

счётчики: overrun/underrun/dropped

В asr_debug:

заменить прямой audio_i2s_read() на audio_stream_read_mono_s16()

сделать loopback опциональным (compile-time define)

убрать esp_restart() из debug-задачи (только лог + backoff)

Дальше сразу WakeNet (M3.1):

подключаем ESP-SR компонент

отдаём ему буфер mono s16 16 kHz





Итоговый “handoff” на сегодня (коротко)
Что сделали / что проверили

DOA probe стабильно читает AEC_AZIMUTH_VALUES, лог идёт, угол живой.

Подняли файловое хранилище storage (spiffs), файлы видны (/spiffs/voice/test_tone_1k_2s.pcm).

Подняли аудио тракт: AUDIO_I2S стартует, AUDIO_STREAM работает.

Начали тестовый audio_player для проигрывания PCM из /spiffs.

Что сломалось / ключевая проблема

При автозапуске проигрывания аудио словили stack overflow в task audio_player → ребут.

На фоне переполнения наблюдается повреждение строки пути (/spiffs/☺♠) и ошибки fopen.

P0 правки (обязательные)

Увеличить stack audio_player task: 4096 → 8192/12288.

Убрать крупные буферы со стека: in_s16/out_i2s сделать static или heap.

audio_i2s_tx_set_enabled(true) не должен фейлить на “already enabled” (считать как OK).

Добавить sanity-check пути перед fopen.

Что делать следующим шагом

После стабилизации player:

добавить нормальный stop/cleanup (тишина + disable TX, это уже заложено),

затем переходить к формату ADPCM и/или к воспроизведению через XVF (если подтвердится по докам),

и дальше по плану: WakeNet/MultiNet интеграция + voice FSM