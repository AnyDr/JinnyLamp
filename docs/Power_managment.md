Принял. Сенс-кнопку **не трогаем вообще**. Пультовую “долгую power” переписываем под **реальный SOFT OFF** (и на пульте тоже можно править). ACK не расширяем: **power-state локален лампе**. Сервер закладываем сразу: “off” с сервера = **SOFT OFF**.

Ниже: **чёткое ТЗ (референс)** + **план шагов правок** (с файлами/точками интеграции, рисками, проверками). Без кода.

---

# A) Техническое задание: Power OFF logic v2 (референс)

## A1. Цель

Перевести “выкл/вкл” лампы на **реальный power state**, без имитации через `paused + brightness=0`.

## A2. Инварианты (не нарушать)

1. **Сенсорная кнопка (TTP223)**: логика/жесты/путь deep sleep остаются как есть. Никаких UX изменений и минимум изменений в коде (в идеале 0).
2. **WS2812 safety sequence** для выключения/включения:

   * OFF: `matrix_anim_stop_and_wait()` (join) → `DATA=LOW` → `MOSFET OFF`
   * ON: `DATA=LOW` → `MOSFET ON` → `delay` → старт anim/show
3. **DOA живёт всегда**, не должен зависеть от состояния LED/anim.
4. **ESPNOW живёт в SOFT OFF**, принимает команды.
5. **ACK не расширяем**: power-state не передаётся обратно (локальная истина лампы).

## A3. Power-модель (лампа)

Ввести явное состояние:

* `POWER_ON`
* `POWER_SOFT_OFF`
* (опционально внутреннее `POWER_TRANSITION` или флаг “busy”, чтобы сериализовать переходы)

Deep sleep не обязан быть частью общей модели (может быть “терминальным путём”), но **SOFT OFF** обязан быть отдельным состоянием.

## A4. Источники команд

Лампа должна принимать power-запросы из:

* **Remote (пульт)**: долгий тап “power” → SOFT OFF / ON.
* **Server (будущее)**: “off” → SOFT OFF, “on” → ON.
* **Local button**: long → DEEP SLEEP (не трогаем).

## A5. Семантика команд

### A5.1 Remote POWER OFF

* Переводит лампу в `POWER_SOFT_OFF`.
* Никаких `paused/brightness` костылей.
* Должно быть идемпотентно: повторный OFF в SOFT OFF безопасен (no-op, кроме логов).

### A5.2 Remote POWER ON

* Выводит из `POWER_SOFT_OFF` в `POWER_ON`.
* Восстанавливает LED подсистему (MOSFET ON, anim старт).
* Пользовательские настройки `brightness/speed/effect_id/paused` сохраняются (не затирать).

### A5.3 Server POWER OFF/ON

* Идентично remote, только другой `source` для логов/приоритета.
* “off” с сервера **всегда SOFT OFF**, никаких deep sleep.

### A5.4 Локальная кнопка

* Не изменяется. Всё.

## A6. Роутинг и “единственный источник истины”

* `ctrl_bus` остаётся источником истины для **эффекта/яркости/скорости/paused**, но не для power.
* Power-state хранится отдельно (power_mgr).

## A7. Логирование/диагностика

При каждом запросе и при каждом завершённом переходе:

* from → to
* source (REMOTE/SERVER/LOCAL)
* результат stop(join): ok/timeout
* факт MOSFET: set ON/OFF
* (опц.) причина (cmd id / payload)

---

# B) Архитектура решения (как именно скрестить текущие узлы)

## B1. Что “оставляем как есть”

* Весь код распознавания TTP223 жестов и deep sleep путь (не трогаем).
* `matrix_anim_stop_and_wait()` как основной join-механизм.
* Протокол ACK (без power поля).
* DOA подсистему.

## B2. Что “ломаем и выкидываем”

* В обработке `J_ESN_CMD_POWER` (лампа):
  **удаляем** маппинг POWER → `paused+brightness=0` + `last_nonzero_brightness`.

Это теперь запрещённая семантика (имитация).

## B3. Что добавляем

Минимальный “power manager” на стороне лампы:

* Хранит `power_state`.
* Имеет 2 публичные операции:

  * `enter_soft_off(source)`
  * `exit_soft_off(source)`
* Сериализует переходы (mutex/critical section), чтобы не поймать гонку если прилетят два power события подряд.

**Где жить:**

* Вариант 1 (минимально): в `main.c` как static helper + state.
* Вариант 2 (чище): новый модуль `power_mgr.c/h`.

С учётом будущего сервера я бы делал **отдельным модулем**, чтобы сервер потом не тащил зависимости `main.c`.

---

# C) План правок по шагам (без спешки, с checkpoint’ами)

Ниже шаги специально так, чтобы каждый шаг был проверяем и откатываем.

## Шаг 0. Git checkpoint

Команды (пример, без новой ветки):

```bash
git status
git add -A
git commit -m "checkpoint: before soft-off refactor"
git tag -a checkpoint/before_soft_off_v2 -m "before soft-off refactor v2"
git push
git push origin checkpoint/before_soft_off_v2
```

---

## Шаг 1. Инвентаризация: найти “точки выключения” в коде (только чтение)

Цель: перечислить все места, где:

* стопается anim
* дёргается MOSFET
* принуждается DATA=LOW
* вызывается deep sleep

Файлы:

* `main.c`
* `matrix_anim.c/h`
* `matrix_ws2812.c/h`
* `j_espnow_link.c`
* (если есть) `led_control.c` или `xvf_i2c.c` (если там MOSFET)

Артефакт шага: мини-таблица “функция → делает что”.

---

## Шаг 2. Добавить power_mgr каркас (без подключения ESPNOW)

**Цель:** добавить модуль/хелперы, которые умеют:

* `enter_soft_off()`: stop(join) → DATA low → MOSFET off
* `exit_soft_off()`: DATA low → MOSFET on → delay → start anim (или “resume”)

**Важно:** на этом шаге НЕ трогаем ESPNOW обработчик POWER, не меняем поведение системы.

Файлы:

* новый `power_mgr.c/h` (предпочтительно)
* или `main.c` (если очень хочешь без новых файлов)

Проверка:

* сборка
* ручной вызов (временно): например из `app_main()` один раз вызвать enter/exit по таймеру (но это уже изменение поведения). Лучше сделать “тестовую функцию”, но не подключать.

Checkpoint:

```bash
git commit -m "power: add soft-off manager skeleton (not wired)"
git tag -a checkpoint/power_mgr_skeleton -m "soft-off manager skeleton"
git push && git push origin checkpoint/power_mgr_skeleton
```

---

## Шаг 3. Провести “dry-run” тест без ESPNOW (контролируемо)

**Цель:** убедиться, что последовательность реально гасит матрицу и потом возвращает.

Как тестировать без изменения UX:

* Самый безопасный вариант: добавить временный compile-time `#define POWER_MGR_SELFTEST 0/1`
* При `=1` после boot через `vTaskDelay(3000)` сделать enter_soft_off, через `vTaskDelay(3000)` exit_soft_off.
* По умолчанию `=0` (не влияет).

Проверки на железе:

* После soft off матрица реально погасла (MOSFET OFF).
* После on матрица вернулась и эффекты продолжили.
* Никаких ребутов/валидаций watchdog.

Checkpoint:
`checkpoint/soft_off_sequence_hw_ok`

---

## Шаг 4. Подключить ESPNOW POWER к power_mgr (главная замена)

**Цель:** реальная семантика power-команды.

Файл:

* `j_espnow_link.c` обработчик `J_ESN_CMD_POWER`

Изменения:

* OFF → `power_mgr_enter_soft_off(SRC_REMOTE)`
* ON → `power_mgr_exit_soft_off(SRC_REMOTE)`
* Удалить `last_nonzero_brightness` логику из этого пути.

**Важно:** paused/brightness команды от пульта должны продолжить работать как раньше, но если лампа в SOFT OFF:

* либо игнорировать их (логировать “ignored in soft-off”),
* либо кешировать и применить при выходе.
  Минимально и безопасно: **игнорировать**, потому что anim не запущен.

Проверки:

* Долгий power на пульте = реальное выключение
* Повторный OFF не ломает
* ON возвращает

Checkpoint:
`checkpoint/remote_power_soft_off_ok`

---

## Шаг 5. Заложить серверный путь (скелет)

**Цель:** чтобы потом не резать систему “с нуля”.

Добавить API:

* `power_mgr_request(PWR_ON|PWR_SOFT_OFF, SRC_SERVER)`

И заглушку-комментарий: “сюда будет приходить команда от bridge”.

Никакого сетевого кода на этом шаге, только интерфейс.

Checkpoint:
`checkpoint/server_power_api_stub`

---

## Шаг 6. Финальная полировка: правила взаимодействия с ctrl_bus

**Цель:** исключить конфликт “soft off vs paused/brightness”.

Правила (фиксируем в коде + доке):

* `ctrl_bus.paused` может быть true/false независимо от power_state.
* В `SOFT_OFF` эффекты не рендерим вообще (anim task остановлен).
* Команды смены эффекта/яркости/скорости в SOFT OFF либо игнор, либо сохраняются но применяются на выходе.
  Я бы сделал так:

  * сохраняются в ctrl_bus (это “настройка”),
  * но не применяются к движку, пока в SOFT OFF.

Это безопаснее, чем терять команды.

---

# D) Открытые решения (минимум, но нужно зафиксировать заранее)

1. **Как точно пульт будет отличать “долгий power” от “короткий power”**
   Ты сказал “не помню, переделаем”. Ок. Для лампы достаточно, чтобы в итоге приходил `J_ESN_CMD_POWER 0/1` только когда это “реальный power”.
   Если сейчас короткий power тоже шлёт `POWER=0`, это сломает UX (будет выключать). Значит правка пульта обязательна синхронно.

2. **Поведение команды brightness=0**
   Теперь это просто “0”, а не power. Это уже ок.

---

# E) Что мне нужно от тебя перед тем, как превращать это в “шаги с точными вставками”

Чтобы следующий этап был не “план”, а “вставь вот сюда”, мне надо:

* подтверждение: будем ли делать `power_mgr.c/h` отдельным модулем (я рекомендую да)
* и один факт: в лампе управление MOSFET сейчас идёт через какую функцию (в `matrix_ws2812.c` или отдельный `led_control.c`). Я найду это по файлам, но ты можешь ускорить если скажешь “MOSFET toggling у нас в …”.

Если ок, следующий мой ответ будет: **Шаг 1 (инвентаризация) в виде конкретного списка мест в коде** с 1–2 строками контекста вокруг каждого места (как ты любишь), и потом “операции №1..№5” для первой порции правок.
