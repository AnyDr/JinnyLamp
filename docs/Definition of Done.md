                                            Definition of Done (DoD) + План работ

1) Definition of Done: когда проект “Jinny Lamp” считается завершённым
1.1 Общие инварианты (не обсуждается)

WS2812 power sequencing соблюдается всегда:
DATA=LOW → MOSFET ON → delay → send и stop anim → DATA=LOW → MOSFET OFF.

Единственный show owner: вывод на матрицу делается только из matrix_anim/низкоуровневого драйвера; overlays рисуют только в canvas.

После cold boot лампа не светит “мусором”, не клинит в тасках, не ломает управление.

## 1.2 Управление (локально + пульт)

Сенсорная кнопка TTP223: short/double/triple/long работают стабильно; deep sleep/wake корректны.

Пульт (ESPNOW): power/pause/effect/brightness/speed работают, состояние подтверждается ACK и корректно отображается.


## 1.3 Голосовой цикл (основная “фишка” проекта)

Цепочка должна работать end-to-end:

XVF3800 принимает звук и вычисляет DOA azimuth 0…360°.

XVF передаёт на ESP:

поток аудио (I2S RX, 16 kHz, 2ch, 24-in-32)

и DOA (по control-командам XVF; используем Auto selected beam как источник “истинного угла”).

ESP распознаёт wake word (готовое решение, без обучения/ручной разработки пользователем).

С момента wake и пока пользователь говорит:

запускается анимация “джин”, ориентированная по DOA (угол → положение на круговой сцене),

состояние лампы = LISTENING.

Команда распознаётся локально (минимум: фиксированный набор команд), действие выполняется (power/effect/brightness/speed/режимы).

ESP инициирует голосовой ответ:

аудио-ответ берётся из заранее подготовленных файлов (локально),

отправляется на XVF через I2S TX,

XVF воспроизводит через свой аудиотракт/усилитель,

параллельно показывается SPEAK анимация джина с “движением рта”.

После завершения воспроизведения:

возврат в NORMAL (или прежний режим/эффект),

никаких зависаний/утечек/потери управления.


## 1.4 OTA (обязательная часть завершения)

Команда OTA_START приводит к:

гарантированной остановке анимации (join),

DATA=LOW, MOSFET OFF,

запуску SoftAP + HTTP OTA портала,

корректному завершению по успеху/ошибке/таймауту и возвращению в NORMAL.

Для OTA есть минимум E2E тестов (см. чекпойнты).

## 1.5 Интеграция с домашним сервером (через Ethernet-мост)

В нормальном режиме лампа остаётся ESPNOW-only.

В одной коробке с RPi5 работает Ethernet-Bridge:

принимает состояния/телеметрию от устройств по ESPNOW,

передаёт в HA/сервер по Ethernet (MQTT/HTTP; выбран протокол фиксируется),

команды от HA отправляет обратно нужному устройству по ESPNOW.

Без шифрования ESP-NOW на старте (опционально в будущем).




2) План работ с чекпойнтами (Milestones)

Формат: Mx.Y = шаг.
Каждый milestone заканчивается проверкой/критерием приёмки, чтобы ясно где мы находимся.

M0. Стабильность платформы (блокер для всего)

Цель: убрать “клин” и сделать безопасные переходы режимов.

## M0.1 Stop=Join для matrix_anim

Реализовать “остановка анимации” как blocking join, без угадываний vTaskDelay.

Критерий: после stop не остаётся task, который может трогать show/буфер.

## M0.2 Единый путь “Safe LED shutdown”

helper: stop(join) → DATA=LOW → MOSFET OFF.

Использовать в: power-off, deep sleep, OTA_START, error path.

## M0.3 OTA lifecycle (happy + timeout)

Закрыть путь: OTA_START → SoftAP/portal → upload → set boot partition → reboot → normal.

Таймаут 300s: корректное выключение OTA режима и возврат.



✅ Приёмка M0:

50 циклов power on/off без “матрица не включилась”. (ок)

10 циклов OTA_START + timeout без зависаний и с корректным возвратом. (ок)

## M1. DOA: XVF → ESP (без голоса, только телеметрия)

Цель: ESP получает стабильный угол 0…360°. (ок)

## M1.1 Реализация чтения DOA

Использовать XVF control параметр AEC_AZIMUTH_VALUES, брать Auto selected beam. (ок)

Вывести угол в градусах (0…360), определить ноль/направление (соглашение координат). (ок)

## M1.2 Стабилизация

Deadband (например ±5°) + сглаживание (EMA/median). (ок)

Выход: doa_deg_filtered + doa_valid. (ок)




✅ Приёмка M1:

При голосе слева/справа угол меняется адекватно, без “дребезга лица”. (ок)

## M2. Audio IN: XVF → ESP (под wake/ASR)

Цель: непрерывный аудиопоток на ESP для wake и команд. (ок)

## M2.1 Стандартизация формата

Вход сейчас: 16 kHz, 2ch, 24-in-32. (ок)

Для wake/ASR приводим к: 16 kHz mono s16 (downmix/выбор канала + shift/saturate). (ок)

## M2.2 Буферизация и устойчивость

Ringbuffer, контроль overruns/underruns. (ок)

Отладочный VAD/уровень энергии. (ок)



✅ Приёмка M2:

10 минут непрерывного стрима без underrun/overrun, CPU/PSRAM в пределах.

M3. Wake word (готовое решение)

Цель: wake word детектится надёжно и запускает LISTEN state.

M3.1 Выбор и интеграция wake engine

Базовый вариант: Espressif WakeNet (ESP-SR).

Интеграция модулем wakeword.c (вход: mono s16 frames → выход: event).

M3.2 Машина состояний голоса

IDLE → LISTENING (после wake) → PROCESS → SPEAK → IDLE

Таймауты и отмена.



✅ Приёмка M3:

100 срабатываний wake без пропусков в типичном шуме комнаты (и приемлемое число ложных).

M4. Команды (локальный набор) + выполнение

Цель: после wake распознаём и выполняем команды.

M4.1 Определить фиксированный набор команд v1

Минимум: power on/off, pause, next/prev effect, brightness up/down, speed up/down.

M4.2 Интеграция распознавания

Вариант A: Espressif MultiNet (если подходит по языку/набору).

Вариант B: иной готовый offline ASR под ESP (если будет выбран отдельной задачей).

Выход: cmd_id + params → ctrl_bus.



✅ Приёмка M4:

Каждая команда выполняется корректно 20/20 в бытовых условиях.

M5. “Джин” анимация по DOA (LISTEN/SPEAK)

Цель: визуальная магия синхронизирована с голосом.

M5.1 Genie LISTEN overlay

Активируется на LISTENING.

Направление = doa_deg_filtered.

Не ломает текущий эффект (overlay или временная замена, решение фиксируется).

M5.2 Genie SPEAK overlay

Во время воспроизведения ответа.

“Рот двигается” (амплитуда от уровня аудио TX или заранее заданный паттерн).



✅ Приёмка M5:

LISTEN: ориентация адекватна при перемещении говорящего.

SPEAK: рот “живёт”, нет артефактов на матрице, управление не блокируется.

M6. Audio OUT: ESP → XVF (записанные ответы)

Цель: лампа отвечает голосом через XVF, без глюков.

M6.1 Поднять I2S TX

Тест: тон/шум/короткий PCM, проверка устойчивости (underrun).

M6.2 Плеер фраз из памяти

Файлы заранее подготовлены и лежат в FS (формат фиксируется: PCM/WAV/ADPCM).

Декодирование → PCM → I2S TX.

M6.3 Политика во время SPEAK

На время ответа: либо временно “stop listening”, либо AEC/мьют (решение фиксируется).



✅ Приёмка M6:

50 воспроизведений подряд без заиканий и без клина voice state.

M7. Ethernet Bridge (RPi5 + много устройств по ESPNOW)

Цель: HA/сервер управляет устройствами через мост, лампы остаются ESPNOW-only.

M7.1 Выбор железа моста

Вариант по умолчанию: ESP32-S3 + W5500 (SPI Ethernet).

Мост в одной коробке с RPi5, соединение по Ethernet (через свитч/порт/внутренний патч).

M7.2 ESP-NOW hub на мосте

peers ≤ 15, таблица MAC/node_id.

Дедуп по seq, TTL/offline статус.

Команды от сервера → отправка peer’у, ожидание ACK.

M7.3 Протокол к серверу

MQTT на проводе (предпочтительно):

publish state (retain), publish tele, subscribe cmd.

HA entities: light/select/number/sensor.



✅ Приёмка M7:

HA видит устройство, может менять power/effect/brightness/speed.

Статус в HA соответствует реальности (ACK/state_seq).




3) Карта статуса “где мы сейчас” (по известным данным)

Управление LED/пульт/кнопка: близко к готовому, но требует закрыть M0 (stop=join + safe shutdown).

OTA: частично есть, но завершённость = через M0.3 E2E.

DOA/Voice: концепт согласован, частично подготовлено (I2S RX есть), но до DoD нужно M1–M6.

Bridge: выбран подход (Ethernet), реализация впереди (M7).