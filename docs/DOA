## 1) Что внутри XVF3800 реально происходит (в терминах XMOS)

XVF3800 держит **4 “луча/beam’а”** и для каждого умеет отдавать **азимут**:

Команда **`AEC_AZIMUTH_VALUES`** возвращает 4 угла (azimuth):

1. focused beam 1
2. focused beam 2
3. free running beam
4. auto selected beam ([XMOS][1])

Параллельно он считает **speech energy (spenergy)** тоже **для каждого из этих 4 лучей**:
Команда **`AEC_SPENERGY_VALUES`** отдаёт 4 float-значения, соответствующие тем же лучам.
Идея простая:

* **spenergy != 0** означает “скорее всего, в луче есть речь”
* значение выше обычно означает “громче/ближе”, но на него влияют шум/эхо/реверб ([XMOS][1])
* **auto selection algorithm может переключаться быстро**.
* **free running beam специально “быстрый и чувствительный”**, чтобы ловить нового говорящего, но из-за этого он может хватать и шумы. ([XMOS][1])

То есть сырые azimuth’ы (особенно free/auto) по определению могут выглядеть “нервно”.

---

## 2) Как XMOS предлагает делать DOA-индикацию “как у них”

Чтобы у системы был **один стабильный “куда говорит сейчас”**, XVF3800 делает *ещё один* вычисленный DOA:

Команда **`AUDIO_MGR_SELECTED_AZIMUTHS`** возвращает 2 значения:

1. **processed azimuth**:

   * **будет NaN, если речи нет**
   * иначе это **азимут текущего говорящего**
2. **текущий азимут auto-select beam** (второе число) ([XMOS][1])

Это и есть **“правильный” DOA для UI-индикатора**, потому что он уже **смешивает speech energy + azimuth**, чтобы получился один “смысловой” угол присутствия говорящего. ([XMOS][1])

Их же инструменты визуализации (`doa_plot.py`) строятся вокруг этой идеи: показывать/использовать “processed” DOA, а не пытаться вручную склеивать дерганые лучи. ([XMOS][1])

---

## 3) Как это должно выглядеть у нас на лампе (идеальное целевое поведение)

### 3.1. Источник истины для угла

**Для анимации джина** (и для отладки “точно как у XVF”) берем:

* `processed_azimuth_deg` из **`AUDIO_MGR_SELECTED_AZIMUTHS`**
* если **NaN**: считаем “речи нет” и **не двигаем DOA**, а **гасим/плавно затухаем** индикатор.

**Не опираемся** на:

* auto beam из `AEC_AZIMUTH_VALUES[3]` как основной DOA (он по задумке может быстро перескакивать) ([XMOS][1])

### 3.2. Источник “насколько сильно светить” (уровень/высота/яркость)

Для “голосового мячика” логично использовать **speech energy**:

* читаем `AEC_SPENERGY_VALUES` (4 штуки) ([XMOS][1])
* берем **энергию луча, который соответствует “активному говорящему”**.

Тут есть 2 корректных варианта:

1. **простая модель**: берем `spenergy` у **auto-select beam** (четвертый) как “уровень присутствия речи” (обычно совпадает с тем, что выбрано как лучший луч).
2. **более “по уму”**: выбираем max(spenergy) среди 4, но **только если processed azimuth не NaN** (иначе можно ловить шум).

Дальше делаем нормальную envelope-логику:

* `level` = clamp+нормализация spenergy
* `spot_brightness = base * level` (как ты и сказал)
* можно добавить attack/release, чтобы не дрожало по яркости.

### 3.3. Геометрия и калибровка угла под твою матрицу

Ты задаёшь эталон:

* **LED0 (первый диод в цепи)** = **0°/360°**
* рост угла **по часовой стрелке** (если смотреть с нужной стороны лампы)

Значит финальная функция маппинга должна быть:

* `deg_mapped = wrap_0_360( inv ? (360 - deg_in) : deg_in )`
* потом `deg_mapped = wrap_0_360(deg_mapped + offset_deg)`
* `offset_deg` делаем **регулируемым**, потому что:

  * ориентация XVF координат зависит от hw-конфига/платы ([XMOS][1])
  * и мы уже видели сдвиг на ~180° в реальности (это как раз “offset” история)

Важно: **инверсию (inv)** тоже оставляем переключаемой, чтобы не перепутать направление при “правильном” offset.

---

## 4) Что именно мы должны увидеть в логах в “идеальном” мире

Раз в секунду (в debug-режиме):

* `processed_deg` (и флаг valid = not NaN)
* `auto_deg` (как вспомогательное)
* `spenergy[4]` или хотя бы выбранный `level`
* применённые `offset_deg` и `inv`
* итоговый `mapped_deg`

И главное: **когда нет речи** processed должен уходить в **NaN** и индикатор должен **гаснуть**, а не “беситься”. ([XMOS][1])



XMOS сам подчёркивает, что spenergy одновременно про “наличие речи” и “амплитуду”, но на неё влияют шум/эхо/реверб, поэтому сглаживание и пороги обязательны. ([XMOS][1])


1. DOA для FX: только `AUDIO_MGR_SELECTED_AZIMUTHS` (processed azimuth, NaN=нет речи)
2. level: `AEC_SPENERGY_VALUES` + нормализация + attack/release
3. калибровка: `offset_deg` + `inv` + wrap 0..360
4. debug: лог раз в 1с, строго отключаемый compile-time/define


[1]: https://www.xmos.com/documentation/XM-014888-PC/pdf/xvf3800_user_guide_v3.2.1.pdf "XMOS XVF3800"

по анимации:
угол берём из processed azimuth

яркость/высоту берём из speech energy

добавляем envelope (attack/release), чтобы мячик не был “припадошным” на речевых пиках/паузах

XMOS сам подчёркивает, что spenergy одновременно про “наличие речи” и “амплитуду”, но на неё влияют шум/эхо/реверб, поэтому сглаживание и пороги обязательны.


Самочеклист (задача соблюдать для ИИ неукоснительно)
Мини-чеклист “перед тем как я пишу план/патч”

 Я вижу актуальный HEAD и файлы из него

 Я могу указать точную строку/фрагмент, который меняю

 Я понимаю compile-time define’ы (из CMakeLists/sdkconfig)

 Я понимаю физическую ориентацию (W/H и LED0)





файлы для анализа проекта
main/xvf_i2c.c

main/xvf_i2c.h

main/fx_effects_doa_debug.c 

main/fx_engine.c

main/fx_engine.h

main/fx_registry.c

main/fx_registry.h