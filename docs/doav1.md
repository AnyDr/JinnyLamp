## Цель DOA 

**Debug-визуализация отдельным эффектом** (1 пиксель):

* **X (0..15)** = направление (DOA), с **offset_deg** и **inv**, wrap 0..360.
* **Y (0..47)** = “громкость/уровень речи” (чем громче, тем выше).
* Ниже порога уровень = 0, пиксель **не горит**.
* **Deadband 5°** (не дёргаться на мелких колебаниях).
* Всё это живёт **отдельным эффектом** `DOA_DEBUG`, который **появляется/пропадает** в списке эффектов на пульте по `CONFIG_J_DOA_DEBUG=0/1` (реестр эффектов компилируется, пульт подтянет список с лампы).

**Источник DOA** (официально подтверждённый и без угадываний по ID):

* Используем `AEC_AZIMUTH_VALUES` (**resid=33, cmd=75, len=16**), берём **4-е значение** (auto-selected beam), это float в радианах, конвертим в градусы. ([wiki.seeedstudio.com][1])
  Официально также существует `DOA_VALUE` (**resid=20, cmd=18, len=4**) как альтернативный/резервный путь (там есть флаг речи + DOA), но целевой путь сегодня оставляем через `AEC_AZIMUTH_VALUES`. ([wiki.seeedstudio.com][1])

**Источник уровня (Y)**:

* Целевой по ТЗ: `AEC_SPENERGY_VALUES` (есть в документации команд XVF), но **официальные numeric resid/cmd в открытых доках не нашёл** (и не буду выдумывать).
* Поэтому на сегодня делаем правильно и быстро: **берём уровень из уже существующей системы автокалибровки шума** (то есть из `asr_debug`), параллелим поведение: noise_floor → нормализация → attack/release → порог.

Три типовых причины ошибок которые нужно избежать:

1. **Неправильный источник/формат**: DOA из XVF идёт в радианах/float, при неверном парсинге (endian/align) будет мусор.
2. **Неправильная система координат**: перепутаны 0° и направление роста по X, плюс offset/inv.
3. **Уровень речи**: если порог/нормализация не привязаны к noise_floor, пиксель либо всегда горит, либо всегда молчит.

## Анализ проекта (где DOA точно будет затрагивать код)

По присланным файлам, точки интеграции такие:

* `xvf_i2c.{c,h}`: сейчас это “транспорт” I²C к XVF. Нам нужно добавить **публичный generic read** (resid/cmd/len), чтобы DOA_ctrl мог читать `AEC_AZIMUTH_VALUES`, не копируя низкоуровневую I²C-кухню по проекту.
* `asr_debug.{c,h}`: уже есть автокалибровка шума. Нам нужен **один экспортируемый getter уровня** (0..255 или 0..1000) либо структурка, чтобы DOA_DEBUG мог взять Y.
* `fx_registry.{c,h}`: добавить эффект `DOA_DEBUG` **условно по `CONFIG_J_DOA_DEBUG`**, чтобы он физически появлялся/пропадал на пульте.
* `fx_engine`/`fx_canvas`: сам рендер 1 пикселя реализуем как обычный effect render.
* `main.c`: инициализация `DOA_ctrl` (создать задачу/poll), чтобы данные обновлялись независимо от того, открыт эффект или нет (или минимально: обновлять в самом эффекте, но тогда без эффекта DOA не логируется).

## Подробный план действий (с шагами и рисками)

**Шаг 0 (без кода):** зафиксировать Kconfig-параметры (одно место, один флаг).

* `CONFIG_J_DOA_DEBUG` (0/1)
* `CONFIG_J_DOA_OFFSET_DEG` (int, default 0)
* `CONFIG_J_DOA_INV` (bool, default n)
* `CONFIG_J_DOA_DEADBAND_DEG` (int, default 5)
* `CONFIG_J_DOA_LOG` (bool, default n) и завязать на `CONFIG_J_DOA_DEBUG`, чтобы “одной кнопкой” рубить и лог и эффект.

**Шаг 1:** расширить `xvf_i2c` минимально:

* добавить `xvf_cmd_read(resid, cmd, payload_len, out_buf)` (или аналог), где внутри строго соблюдается формат “status + payload”.
* Риск: сломать существующий GPO-код. Митигируем: старые API не трогаем, добавляем новое.

**Шаг 2:** создать `doa_ctrl.{h,c}`:

* FreeRTOS task с периодом (например 50 ms) читает `AEC_AZIMUTH_VALUES`, парсит 4-й float, NaN → invalid.
* берёт `level` из `asr_debug_get_level()` (новый getter).
* применяет deadband 5° + сглаживание (опционально, простое).
* раз в 1 секунду печатает лог (если debug включён).

**Шаг 3:** добавить эффект `DOA_DEBUG`:

* в render: очистить кадр, если invalid/level<thr → пусто; иначе поставить 1 пиксель `(x_from_doa, y_from_level)` и `present`.
* в `fx_registry`: регистрировать только при `CONFIG_J_DOA_DEBUG=1`.

**Шаг 4:** быстрый тест:

* Serial: видим лог 1 Гц.
* Визуально: пиксель прыгает по X при речи вокруг, по Y при громкости.


Вывод: весь DOA-пайплайн дальше декодируем как float32 LE.